#!/bin/sh
# Sync notify: email -Sn 
# Count all: email -Ca 

MAIL_DIR="$HOME/.mail"
CACHE_DIR="$HOME/.cache/jeros"

stderr() {
	echo "$*" 2>&1
}

die() {
	stderr "$0: $*"
	exit 1
}

unread() {
	find "$MAIL_DIR"/*/Inbox/new -type f
}

mail_count() {
	if [ -z "$MAIL_COUNT" ]; then
		MAIL_COUNT="$(unread | wc -l)"
	fi
	echo "$MAIL_COUNT"
}

is_new_mail() {
	stderr "checking for new mail"
	mkdir -p "$CACHE_DIR"
	# latest is based on the premise that email file names are
	# prefixed with their Unix timestamp
	latest=$(unread | sort -nr | awk -F '/' '{ print $(NF); exit; }')

	# the one we saw on the last invocation of is_new_mail
	saw_last_time=$(cat "$CACHE_DIR/email_notify")

	echo "$latest" > "$CACHE_DIR/email_notify"

	[ "$latest" -gt "$saw_last_time" ] && [ "$(mail_count)" -gt 0 ] ||
		return 1

}

sync() {
	stderr "syncing mail"
	if [ -n "$INTERACTIVE" ]; then
		notify 'Mail' "Syncing mail..."
	fi

	msmtp-runqueue.sh && mbsync -a || return "$?"

	if is_new_mail || [ -n "$INTERACTIVE" ]; then
		if [ "$MAIL_COUNT" -eq 0 ]; then
			count='no'
		else
			# TODO this sets count to "" - fix me
			count="$MAIL_COUNT"
		fi
		notify 'Mail' "You've got $count new mail."
		play "$HOME/Media/Audio/Recordings/bow.mp3" vol 0.25
	fi
}

# TODO: open in dvtm terminal
open() {
	stderr "openning"
	if [ -t 0 ] && [ -t 1 ] && [ -t 2 ]; then
		exec "$EMAIL_CLIENT" -f "$MAIL_DIR/$1/Inbox"
	else 
		exec "$TERMINAL" -e "$EMAIL_CLIENT" -f "$MAIL_DIR/$1/Inbox"
	fi
}

main() {
	while getopts ":SO:" opt; do
		case "$opt" in 
			S) sync;;
			O) open "$OPTARG";;
			*) die "getopts returned '$opt'";;
		esac
	done
}

# Check if its being sourced before running
echo "$0" | grep -Eq '/bin/(ba|z|k)?sh$' || main "$@"
